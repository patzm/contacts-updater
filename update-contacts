#! /usr/bin/env python3

import argparse
import configparser
import hashlib
import logging
import os
import sys
from abc import abstractmethod
from typing import List, Optional, Tuple

import AddressBook
import AppKit
import Foundation
import Contacts
import appdirs
import Levenshtein
import requests
from selenium import webdriver
from selenium.common import exceptions
from selenium.webdriver.common.by import By
from selenium.webdriver.support import expected_conditions, wait

"""Logging"""
app_name = "update-contacts"
log_file_dir = appdirs.user_cache_dir(app_name)
os.makedirs(log_file_dir, exist_ok=True)
logging.basicConfig(filename=os.path.join(log_file_dir, "log.txt"), level=logging.DEBUG)

logger = logging.getLogger(app_name)
logger.setLevel(logging.NOTSET)


def read_img(file_path: str) -> Foundation.NSImage:
    image = Foundation.NSImage.alloc().initWithContentsOfFile_(file_path)
    return image


def write_img(image_data: Foundation.NSData, file_path: str, file_format: int):
    image = Foundation.NSImage.alloc().initWithData_(image_data)
    image.lockFocus()
    rect = Foundation.NSMakeRect(0.0, 0.0, image.size().width, image.size().height)
    img_rep = AppKit.NSBitmapImageRep.alloc().initWithFocusedViewRect_(rect)
    image.unlockFocus()

    data = img_rep.representationUsingType_properties_(file_format, None)
    data.writeToFile_atomically_(file_path, False)


def person_get_name(person: AddressBook.ABPerson) -> Tuple[str, str]:
    first_name = person.valueForProperty_(AddressBook.kABFirstNameProperty) or ""
    last_name = person.valueForProperty_(AddressBook.kABLastNameProperty) or ""
    return first_name, last_name


class Provider:
    @abstractmethod
    def get_image(self, file_name: str) -> bool:
        ...


class GravatarProvider(Provider):
    def get_image(self, file_name: str, person: AddressBook.ABPerson) -> bool:
        email_store = person.valueForProperty_(AddressBook.kABEmailProperty)
        n_emails = AddressBook.ABMultiValueCount(email_store)
        emails = [
            AddressBook.ABMultiValueCopyValueAtIndex(email_store, idx).encode().decode()
            for idx in range(n_emails)
        ]

        for email in emails:
            email_hash = hashlib.md5(email.lower().strip().encode()).hexdigest()
            url = f"https://www.gravatar.com/avatar/{email_hash}.jpg?d=404&s=500"
            logger.info(f"\t- e-mail: {email}\n\t  request: {url}")
            picture_request = requests.get(url, allow_redirects=True)
            if picture_request.status_code != 404:
                with open(file_name, "wb") as picture_file:
                    picture_file.write(picture_request.content)
                return True

        return False


class LinkedInProvider(Provider):
    def __init__(self, username: str, password: str):
        self.driver = webdriver.Firefox()
        self.driver.get("https://linkedin.com/login")

        username_field = self.driver.find_element(by=By.ID, value="username")
        username_field.clear()
        username_field.send_keys(username)

        password_field = self.driver.find_element(by=By.ID, value="password")
        password_field.clear()
        password_field.send_keys(password)

        login_button = self.driver.find_element(
            by=By.CSS_SELECTOR, value="[type='submit']"
        )
        login_button.click()

        if self.driver.current_url == "https://www.linkedin.com/check/manage-account":
            raise NotImplementedError(f"The account management dialog isn't implemented. Please manually approve it.")

        self._img_classes = {
            "pv-non-self-member-photo-modal__image",
            "pv-top-card-profile-picture__image",
        }

    def __del__(self):
        self.driver.close()

    def search_profile(self, first_name: str, last_name: str) -> Optional[str]:
        if not last_name or not first_name:
            return None

        name = f"{first_name} {last_name}"
        url = (
            f"https://www.linkedin.com/search/results/people/?"
            f"keywords={name}"
            f'&network=["F"]'
            f"&origin=SPELL_CHECK_REPLACE"
            f"&sid=(ol&spellCorrectionEnabled=false"
        )
        self.driver.get(url)
        results = self.driver.find_elements(by=By.CLASS_NAME, value="entity-result")
        if len(results) == 0:
            return None

        # navigate to the first search result
        first_result_link = results[0].find_element(by=By.TAG_NAME, value="a")
        first_result_link.click()
        try:
            wait.WebDriverWait(self.driver, timeout=5).until(
                method=expected_conditions.presence_of_element_located(
                    (By.ID, "profile-content")
                )
            )
        except exceptions.TimeoutException:
            return None

        # Validate name
        heading_elements = self.driver.find_elements(by=By.TAG_NAME, value="h1")
        match = False
        for he in heading_elements:
            if "text-heading-xlarge" in he.get_attribute("class"):
                if Levenshtein.ratio(he.text, name, score_cutoff=0.6):
                    match = True
                    break

        if not match:
            return None

        profile_url = self.driver.current_url
        return profile_url

    def get_image(self, file_name: str, person: AddressBook.ABPerson) -> bool:
        first_name, last_name = person_get_name(person)
        name = f"{first_name} {last_name}"

        profile_url = self.search_profile(first_name, last_name)
        if not profile_url:
            return False

        profile_picture_button = self.driver.find_element(
            by=By.CLASS_NAME, value="pv-top-card__non-self-photo-wrapper"
        )
        profile_picture_button.click()

        picture_element = None
        picture_elements = self.driver.find_elements(by=By.TAG_NAME, value="img")
        for pe in picture_elements:
            if any(
                img_cls in pe.get_attribute("class") for img_cls in self._img_classes
            ):
                picture_element = pe
                break

        if picture_element is None:
            logger.warning(f"{name}: failed to find the picture node.")
            return False

        picture_source = picture_element.get_attribute("src")
        logging.debug(f"{name}: picture url found {picture_source}")

        picture = requests.get(picture_source, allow_redirects=True)
        if picture.status_code == 200:
            with open(file_name, "wb") as picture_file:
                picture_file.write(picture.content)
            return True

        return False


def find_picture_for_person(
    person: AddressBook.ABPerson, file_path: str, providers: List[Provider]
) -> bool:
    first_name, last_name = person_get_name(person)
    name = f"{first_name} {last_name}"

    image_data = person.imageData()
    if image_data:
        logger.info(f"{name}: already has a profile picture.")
        write_img(image_data, file_path, AppKit.NSJPEGFileType)
        return False
    elif os.path.exists(file_path):
        logger.info(f"{name}: A profile picture has already been downloaded.")
        return True
    else:
        logger.info(f"{name}: Getting a profile picture.")
        success = False
        for provider in providers:
            success = provider.get_image(file_name=file_path, person=person)
            if success:
                break

        if success:
            logger.info(f"{name}: Successfully found a profile picture.")
        else:
            logger.warning(f"{name}: Failed to find a profile picture.")

        return success


def apply_picture_for_person(person: AddressBook.ABPerson, file_path: str) -> bool:
    image_data = read_img(file_path)
    tiff_data = image_data.TIFFRepresentation()
    bitmap_image = AppKit.NSBitmapImageRep.alloc().initWithData_(tiff_data)
    jpeg_data = bitmap_image.representationUsingType_properties_(
        AppKit.NSJPEGFileType, None
    )
    return person.setImageData_(jpeg_data)


def main(config: argparse.Namespace):
    output_path = os.path.join(appdirs.user_cache_dir(app_name), "profile-pictures")
    os.makedirs(output_path, exist_ok=True)

    config_dir = appdirs.user_config_dir(appname="update-contacts")
    os.makedirs(config_dir, exist_ok=True)

    credentials_file_path = os.path.join(config_dir, "credentials.ini")
    credentials = configparser.ConfigParser()
    if not os.path.exists(credentials_file_path):
        if config.gen_config_files:
            credentials["linkedin"] = {}
            credentials["linkedin"]["username"] = "your@email.com"
            credentials["linkedin"]["password"] = "your-password"

            with open(credentials_file_path, "w") as credentials_file:
                credentials.write(credentials_file)

            logger.info(
                f"The template credentials file has been written to {credentials_file_path}"
            )
            exit(0)
        else:
            credentials = dict()
            logger.warning(
                f"No 'credentials.ini' file found in {config_dir}. Disabling providers that require credentials.\n"
                f"Provide the --gen-config-files flag to generate a template.\n"
                f"Further reading: https://docs.python.org/3/library/configparser.html"
            )
    else:
        credentials.read(credentials_file_path)

    providers = []
    if (
        not getattr(config.providers, "no_linkedin", False)
        and "linkedin" in credentials
    ):
        providers.append(
            LinkedInProvider(
                username=credentials["linkedin"]["username"],
                password=credentials["linkedin"]["password"],
            )
        )
    if not getattr(config.providers, "no_gravatar", False):
        providers.append(GravatarProvider())

    book = AddressBook.ABAddressBook.sharedAddressBook()
    for person in book.people():
        first_name, last_name = person_get_name(person)
        name = f"{first_name} {last_name}"
        file_path = os.path.join(
            output_path, f"{first_name.lower()}_{last_name.lower()}.jpg"
        )

        should_update = find_picture_for_person(person, file_path, providers)
        if not should_update:
            continue

        success = apply_picture_for_person(person, file_path)
        if success:
            logger.info(f"{name}: New profile picture updated successfully.")
            book.save()
        else:
            logger.warning(f"{name}: Failed updating the profile picture.")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(app_name)
    parser.add_argument(
        "--gen-config-files",
        default=False,
        action="store_true",
        help="Generate the config file templates.",
    )

    subparsers = parser.add_subparsers(dest="providers")
    providers_parser = subparsers.add_parser("providers")
    providers_parser.add_argument(
        "--no-gravatar",
        default=False,
        action="store_true",
        help="Disable the Gravatar provider.",
    )
    providers_parser.add_argument(
        "--no-linkedin",
        default=False,
        action="store_true",
        help="Disable the LinkedIn provider.",
    )

    args = parser.parse_args()

    stdout_handler = logging.StreamHandler(sys.stdout)
    stdout_handler.setLevel(logging.INFO)
    logger.addHandler(stdout_handler)

    main(config=args)
